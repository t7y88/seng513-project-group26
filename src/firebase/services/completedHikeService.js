// @ts-check
/// <reference path="../../types/firestoreModels.js" />

import { db } from "../firebase";
import {
  collection,
  doc,
  setDoc,
  deleteDoc,
  query,
  where,
  getDocs,
  orderBy,
  limit,
  Timestamp,
} from "firebase/firestore";
import {
  generateHikeDocId,
  normalizeDate,
} from "../../../utils/hikeCompletionUtils.js";
import { getFriends, getRecentHikesByFriend } from "./friendshipService";
import { getHikeByHikeId } from "./hikeService";
/**
 * Logs a completed hike to Firestore.
 *
 * Throws:
 * - Error if required fields are missing
 * - Error if Firestore fails to write the document
 *
 * Notes:
 * Uses a composite key for the document ID: `${userId}_${hikeId}_${dateCompleted}`
 * - This composite ID is generated by the helper utility function <generateHikeId()>
 *
 * @param {CompletedHike} data
 * @throws {Error} If required fields are missing or if the document (tuple) was not inserted into the Collection (database)
 * @returns {Promise<void>}
 * @author aidan
 */
export const createCompletedHike = async ({
  id,
  userId,
  username,
  hikeId,
  rating,
  notes,
  dateCompleted,
  timeToComplete,
  timeUnit,
}) => {
  // Validate required fields
  if (
    !userId ||
    !username ||
    !hikeId ||
    typeof rating !== "number" ||
    typeof timeToComplete !== "number" ||
    !timeUnit
  ) {
    throw new Error(
      "Missing required hike data (userId, username, hikeId, rating, timeToComplete, or timeUnit)"
    );
  }

  const date = normalizeDate(dateCompleted ?? new Date());
  // The document ID aka Primary key is a combination of - userID, hikeId, and date - (aka a composite primary key)
  const docId = generateHikeDocId(userId, hikeId, date);
  // We insert the completed hike data into the completedHikes collection
  const ref = doc(db, "completedHikes", docId);

  try {
    await setDoc(ref, {
      id,
      userId,
      username,
      hikeId,
      rating,
      notes,
      dateCompleted: date,
      timeToComplete,
      timeUnit,
      createdAt: new Date(),
    });
  } catch (error) {
    console.error("Failed to log completed hike:", error);
    throw new Error("Failed to save hike. Please try again.");
  }
};

/**
 * Removes a completed hike from the `completedHikes` collection in Firestore.
 *
 *This function constructs the document ID using the user's ID, hike ID, and date the hike was completed,
 * and attempts to delete the corresponding document from Firestore.
 *
 * Throws:
 * - Error if required fields are missing
 * - Error if Firestore encounters an error during deletion.
 *
 * @param {CompletedHike} completedHike - The completed hike object to be removed. Must include `userId`, `hikeId`, and either `dateCompleted` or `dateHikeOccured`.
 * @returns {Promise<void>} A promise that resolves if the document is successfully deleted.
 * @throws {Error} If required fields are missing or if deletion fails.
 *
 * @author aidan
 */
export const removeCompletedHike = async (completedHike) => {
  const { userId, hikeId, dateCompleted } = completedHike;

  if (!userId || !hikeId || !dateCompleted) {
    throw new Error(
      "Missing required fields: userId, hikeId, or date (dateCompleted)."
    );
  }

  const docID = generateHikeDocId(userId, hikeId, dateCompleted);
  const ref = doc(db, "completedHikes", docID);

  try {
    await deleteDoc(ref);
  } catch (error) {
    console.error("Failed to delete completed hike:", error);
    throw new Error(
      "An error occurred while trying to remove the hike from Firestore."
    );
  }
};

/**
 * Retrieves all completed hikes for a specific user.
 *
 * NOTE: This assumes a structure like /completedHikes/{docId}, with userId as a field — not as part of the path.
 * The query should likely be updated to filter by userId instead of including it in the path.
 *
 * @param {string} userId - The ID of the user whose completed hikes should be retrieved.
 * @returns {Promise<CompletedHike[]>} A promise resolving to an array of completed hike objects.
 *
 * @author aidan
 */
export const getCompletedHikes = async (userId) => {
  const completedHikesRef = collection(db, "completedHikes");

  const q = query(
    completedHikesRef,
    where("userId", "==", userId),
    orderBy("dateCompleted", "desc") // Most recent hike comes first
  );

  console.log(userId);

  const snapshot = await getDocs(q);

  //Give me all the document’s fields, and also include the document’s unique ID (key) as id
  return snapshot.docs.map(
    (doc) =>
      /** @type {CompletedHike} */ ({
        id: doc.id,
        ...doc.data(),
      })
  );
};

/**
 * Retrieves a limited number of the most recent completed hikes for a specific user.
 *
 * Results are sorted in descending order of dateCompleted (most recent hikes first).
 * This is useful for previewing a user's recent activity (e.g. in a profile card).
 *
 * @param {string} userId - The ID of the user whose recent hikes should be retrieved.
 * @param {number} numOfHikes - The number of most recent hikes to return.
 * @returns {Promise<CompletedHike[]>} A promise resolving to a list of completed hikes.
 *
 * @author aidan
 */
export const getMostRecentCompletedHikes = async (userId, numOfHikes) => {
  const completedHikesRef = collection(db, "completedHikes");

  const q = query(
    completedHikesRef,
    where("userId", "==", userId),
    orderBy("dateCompleted", "desc"), // Most recent hike comes first
    limit(numOfHikes)
  );

  const snapshot = await getDocs(q);
  //Give me all the document’s fields, and also include the document’s unique ID (key) as id
  return snapshot.docs.map(
    (doc) =>
      /** @type {CompletedHike} */ ({
        id: doc.id,
        ...doc.data(),
      })
  );
};

/**
 * Retrieves completed hikes from user's friends with additional details
 * needed for display in the FriendLog component.
 *
 * @param {string} userId - Current user ID whose friends to check
 * @param {number} [batchSize=10] - Number of hikes to retrieve per batch
 * @param {Object} [startAfterDoc=null] - Firestore document to start after (for pagination)
 * @returns {Promise<{hikeData: Array, lastDoc: Object|null, hasMore: boolean}>}
 */
export const getFriendsCompletedHikesWithDetails = async (
  userId,
  batchSize = 10,
  startAfterDoc = null
) => {
  try {
    // 1. Get the user's friends
    const friends = await getFriends(userId);

    if (!friends.length) {
      return { hikeData: [], lastDoc: null, hasMore: false };
    }

    // 2. Collect all completed hikes from all friends
    const hikePromises = friends.map((friend) =>
      getRecentHikesByFriend(friend.id)
    );

    // Wait for all completed hike data to be retrieved
    const friendsHikesArray = await Promise.all(hikePromises);

    // 3. For each completed hike, fetch the corresponding hike details
    let allHikes = [];

    for (let i = 0; i < friendsHikesArray.length; i++) {
      const friendData = friends[i];
      const completedHikes = friendsHikesArray[i];

      for (const completedHike of completedHikes) {
        try {
          // Fetch the full hike details using the hikeId from completedHike
          const hikeDetails = await getHikeByHikeId(completedHike.hikeId);

          if (hikeDetails) {
            // Store the original timestamp/date object without conversion
            allHikes.push({
              completion: completedHike,
              userId: friendData.id,
              username: friendData.username,
              title: hikeDetails.title,
              image:
                hikeDetails.image ||
                "https://placehold.co/600x400?text=No+Image",
              location: hikeDetails.location || "Unknown Location",
              province: hikeDetails.province || "",
              distance: hikeDetails.distance || "0",
              distanceUnit: hikeDetails.distanceUnit || "km",
              elevation: hikeDetails.elevation || "0",
              elevationUnit: hikeDetails.elevationUnit || "m",
              dateCompleted: completedHike.dateCompleted,
              rating: completedHike.rating || 0,
              notes: completedHike.notes || "",
            });
          }
        } catch (error) {
          console.error(
            `Error fetching details for hike ${completedHike.hikeId}:`,
            error
          );
        }
      }
    }

    // 4. Sort all hikes by date (most recent first)
    allHikes.sort((a, b) => {
      // Safely convert any timestamp format to milliseconds for comparison
      const getTimeMillis = (dateField) => {
        if (!dateField) return 0;

        // Firestore Timestamp with toDate() method
        if (typeof dateField.toDate === "function") {
          return dateField.toDate().getTime();
        }
        // JavaScript Date object
        else if (dateField instanceof Date) {
          return dateField.getTime();
        }
        // Try as string/number timestamp
        else {
          try {
            return new Date(dateField).getTime();
          } catch {
            return 0;
          }
        }
      };

      return (
        getTimeMillis(b.completion.dateCompleted) -
        getTimeMillis(a.completion.dateCompleted)
      );
    });

    // 5. Implement pagination
    const totalHikes = allHikes.length;
    const startIndex = startAfterDoc
      ? parseInt(startAfterDoc.toString(), 10)
      : 0;
    const endIndex = Math.min(startIndex + batchSize, totalHikes);

    const hikesBatch = allHikes.slice(startIndex, endIndex);
    const newLastDoc = endIndex < totalHikes ? endIndex : null;
    const hasMore = endIndex < totalHikes;

    return {
      hikeData: hikesBatch,
      lastDoc: newLastDoc,
      hasMore: hasMore,
    };
  } catch (error) {
    console.error("Error in getFriendsCompletedHikesWithDetails:", error);
    return { hikeData: [], lastDoc: null, hasMore: false };
  }
};
