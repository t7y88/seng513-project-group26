// @ts-check
/// <reference path="../../types/firestoreModels.js" />

import { db } from "../firebase";
import {
  collection,
  doc,
  setDoc,
  deleteDoc,
  query,
  where,
  getDocs,
  orderBy,
  limit,
} from "firebase/firestore";
import {
  generateHikeDocId,
  normalizeDate,
} from "../../../utils/hikeCompletionUtils.js";

/**
 * Logs a completed hike to Firestore.
 *
 * Throws:
 * - Error if required fields are missing
 * - Error if Firestore fails to write the document
 *
 * Notes:
 * Uses a composite key for the document ID: `${userId}_${hikeId}_${dateCompleted}`
 * - This composite ID is generated by the helper utility function <generateHikeId()>
 *
 * @param {CompletedHike} data
 * @throws {Error} If required fields are missing or if the document (tuple) was not inserted into the Collection (database)
 * @returns {Promise<void>}
 * @author aidan
 */
export const createCompletedHike = async ({
  id,
  userId,
  username,
  hikeId,
  rating,
  notes,
  dateCompleted,
  timeToComplete,
  timeUnit,
}) => {
  // Validate required fields
  if (
    !userId ||
    !username ||
    !hikeId ||
    typeof rating !== "number" ||
    typeof timeToComplete !== "number" ||
    !timeUnit
  ) {
    throw new Error(
      "Missing required hike data (userId, username, hikeId, rating, timeToComplete, or timeUnit)"
    );
  }

  const date = normalizeDate(dateCompleted ?? new Date());
  // The document ID aka Primary key is a combination of - userID, hikeId, and date - (aka a composite primary key)
  const docId = generateHikeDocId(userId, hikeId, date);
  // We insert the completed hike data into the completedHikes collection
  const ref = doc(db, "completedHikes", docId);

  try {
    await setDoc(ref, {
      id,
      userId,
      username,
      hikeId,
      rating,
      notes,
      dateCompleted: date,
      timeToComplete,
      timeUnit,
      createdAt: new Date(),
    });
  } catch (error) {
    console.error("Failed to log completed hike:", error);
    throw new Error("Failed to save hike. Please try again.");
  }
};

/**
 * Removes a completed hike from the `completedHikes` collection in Firestore.
 *
 *This function constructs the document ID using the user's ID, hike ID, and date the hike was completed,
 * and attempts to delete the corresponding document from Firestore.
 *
 * Throws:
 * - Error if required fields are missing
 * - Error if Firestore encounters an error during deletion.
 *
 * @param {CompletedHike} completedHike - The completed hike object to be removed. Must include `userId`, `hikeId`, and either `dateCompleted` or `dateHikeOccured`.
 * @returns {Promise<void>} A promise that resolves if the document is successfully deleted.
 * @throws {Error} If required fields are missing or if deletion fails.
 *
 * @author aidan
 */
export const removeCompletedHike = async (completedHike) => {
  const { userId, hikeId, dateCompleted } = completedHike;

  if (!userId || !hikeId || !dateCompleted) {
    throw new Error(
      "Missing required fields: userId, hikeId, or date (dateCompleted)."
    );
  }

  const docID = generateHikeDocId(userId, hikeId, dateCompleted);
  const ref = doc(db, "completedHikes", docID);

  try {
    await deleteDoc(ref);
  } catch (error) {
    console.error("Failed to delete completed hike:", error);
    throw new Error(
      "An error occurred while trying to remove the hike from Firestore."
    );
  }
};

/**
 * Retrieves all completed hikes for a specific user.
 *
 * NOTE: This assumes a structure like /completedHikes/{docId}, with userId as a field — not as part of the path.
 * The query should likely be updated to filter by userId instead of including it in the path.
 *
 * @param {string} userId - The ID of the user whose completed hikes should be retrieved.
 * @returns {Promise<CompletedHike[]>} A promise resolving to an array of completed hike objects.
 *
 * @author aidan
 */
export const getCompletedHikes = async (userId) => {
  const completedHikesRef = collection(db, "completedHikes");

  const q = query(
    completedHikesRef,
    where("userId", "==", userId),
    orderBy("dateCompleted", "desc") // Most recent hike comes first
  );

  console.log(userId);

  const snapshot = await getDocs(q);

  //Give me all the document’s fields, and also include the document’s unique ID (key) as id
  return snapshot.docs.map(
    (doc) =>
      /** @type {CompletedHike} */ ({
        id: doc.id,
        ...doc.data(),
      })
  );
};

/**
 * Retrieves a limited number of the most recent completed hikes for a specific user.
 *
 * Results are sorted in descending order of dateCompleted (most recent hikes first).
 * This is useful for previewing a user's recent activity (e.g. in a profile card).
 *
 * @param {string} userId - The ID of the user whose recent hikes should be retrieved.
 * @param {number} numOfHikes - The number of most recent hikes to return.
 * @returns {Promise<CompletedHike[]>} A promise resolving to a list of completed hikes.
 *
 * @author aidan
 */
export const getMostRecentCompletedHikes = async (userId, numOfHikes) => {
  const completedHikesRef = collection(db, "completedHikes");

  const q = query(
    completedHikesRef,
    where("userId", "==", userId),
    orderBy("dateCompleted", "desc"), // Most recent hike comes first
    limit(numOfHikes)
  );

  const snapshot = await getDocs(q);
  //Give me all the document’s fields, and also include the document’s unique ID (key) as id
  return snapshot.docs.map(
    (doc) =>
      /** @type {CompletedHike} */ ({
        id: doc.id,
        ...doc.data(),
      })
  );
};
